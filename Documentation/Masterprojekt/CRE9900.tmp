\chapter{Implementierungen}
\section{Ethernet}

Dieses Kapitel beschreibt die Einbindung der Ethernet Schnittstelle des Keil MCB1760 Evaluation Boards. Ziel ist es, dass zwei Boards über ihre Ethernet Schnittstelle Daten austauschen können. In der Implementierung nach \citet{Steinmeyer} wurde die gewünschte Funktionalität bereits umgesetzt, jedoch auf der Basis des RTX RL-ARM Echtzeitbetriebssystems und einer damit überholten Version der Keil MDK. Zudem soll die gesamte Implementierung in Rhapsody stattfinden, so dass der generierte Code in der IDE Keil uVision lediglich übersetzt und auf das Target geflasht werden muss. 

Zur Implementierung und Demonstration der Kommunikation über Ethernet wurde eine Entwicklungsumgebung entsprechend der nachfolgenden Abbildung aufgebaut.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth]{images/EthernetAufbau.pdf}
		\caption[Demonstrator Ethernet zwischen zwei Eval Boards]{Demonstrator für die Kommunikation zwischen zwei MCB1760 Evaluation Boards über Ethernet}
	\label{fig:DemonstratorEthernet}
\end{figure}

Wie in \autoref{fig:DemonstratorEthernet} dargestellt, sind die beiden MCB1760 Evaluation Boards über Patchkabel mit einen Hub verbunden. Der Hub hat gegenüber einem Switch oder Router den Nachteil, dass er eine geringere nutzbare Bandbreite mit sich bringt. Grund dafür ist, dass der Hub ein Datenpaket immer an jedes angeschlossene Gerät sendet, unabhängig davon, ob das Datenpaket an das Gerät adressiert wurde oder nicht. Jedoch unterstützt dieses Defizit bei der Implementierung, indem mit Hilfe eines PCs das Tool Wireshark den Datenverkehr zwischen den beiden MCB1760 Evaluation Boards abhört. Da die versendeten Datenpakete eine Größe von zwei Bytes haben, spielt die nutzbare Bandbreite im Rahmen dieser Arbeit keine Rolle. 

\subsection{Anforderungen}\label{subsec:Anforderungen} 

Zur Demonstration einer funktionsfähigen Ethernet-Kommunikation soll ein exemplarisches Szenario implementiert werden. So sollen LEDs durch den Joystick auf dem jeweils anderen Board ein- und ausgeschaltet werden. Dabei soll die Position des Joysticks angeben, welche LED die LED-Bar ein- oder ausschaltet. Des Weiteren soll das Display die zuletzt empfangene Position anzeigen. Damit die MCB1760 Evaluation Boards einfach zu identifizieren sind, soll das Display zudem die Host IP Adresse sowie die Target IP Adresse darstellen. Beim Senden sowie beim Empfangen eines Datenpakets soll der Transmitter bzw. der Receiver kurzzeitig eine LED blinken lassen. Die Zuordnung von Funktionen zu den LEDs der LED-Bar ist \autoref{fig:Szenario} rechts dargestellt. 

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth]{images/Szenario.pdf}
		\caption[Beispiel mit Zuordnung der LEDs]{Beispiel mit Zuordnung der LEDs.}
	\label{fig:Szenario}
\end{figure}

Zudem veranschaulicht \autoref{fig:Szenario} das Funktionsprinzip. Auf dem Host MCB1760 Evaluation Board bewegt der Benutzer den Joystick in die linke Richtung. Das führt dazu, dass beim Remote MCB1760 Evaluation Board die Receiver LED P1.29 kurzzeitig aufleuchtet, sowie die LED P2.3 dauerhaft angeschaltet wird. Bewegt der Benutzer den Joystick erneut in die linke Richtung, erlischt die LED P2.3 wieder.

\subsection{Architektur}
Bei der Formulierung der Anforderungen in Kapitel \ref{subsec:Anforderungen} wurde darauf geachtet, dass diese in möglichst aktiver Form spezifiziert sind. Dadurch können die benötigten Klassen abgeleitet werden, welches sich im Folgenden durch die Ähnlichkeit von Subjekten oder Objekten zu den Klassennamen widerspiegelt.

Die Architektur der Ethernet-Kommunikation ist als Klassendiagramm in \autoref{fig:ClassDiagramEthernet} dargestellt. Zentrales Element ist die Basisklasse \texttt{Ether\-net\-Con\-trol\-ler}, von ihr werden die beiden Klassen \texttt{Ether\-net\-Transmitter} und \texttt{Ether\-net\-Receiver} abgeleitet. Diese beiden Klassen arbeiten in separaten Tasks und sind für das Senden und Empfangen von Datenpaketen verantwortlich. Auf der linken Seite in \autoref{fig:ClassDiagramEthernet} sind die Klassen \texttt{Running\-Indicator\-Led} und \texttt{Joystick} abgebildet, welche ebenfalls in eigenen Tasks ausgeführt werden. Die Klasse \texttt{Running\-Indicator\-Led} lässt die LED P1.31 zyklisch blinken, mit einer Periodendauer von einer Sekunde. Sie dient zu Debugging zwecken und um unmittelbar zu erkennen, ob das Target läuft. Die Klasse \texttt{Joystick} pollt regelmäßig die Position des Joysticks. Auf der rechten Seite sind die Klassen \texttt{LedBar}, \texttt{Display} und \texttt{Led} zu finden. Dabei liegt zwischen den Klassen \texttt{LedBar} und \texttt{Led} eine Komposition mit der Multiplizität vier vor, wodurch der LED-Bar die LEDs zugeordnet sind, welche eine Joystick Position repräsentieren. Außerhalb des Pakets \texttt{DefaultPkg} sind Abhängigkeiten zu externen Bibliotheken in orange eingezeichnet. Die verwendeten Bibliotheken, Network und Graphics Component, stammen aus der MDK Middleware und vereinfachen das Verwenden dieser Peripheriegeräte. Mögliche Vorgehensweisen beim Einbinden externer Quellen beschreiben \citet{ExternalSources}.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth]{images/ClassDiagramEthernet.pdf}
		\caption[Klassendiagramm Ethernet-Kommunikation]{Klassendiagramm zur Ethernet-Kommunikation. Klassen, die in eigenen Tasks laufen sind rot eingezeichnet.}
	\label{fig:ClassDiagramEthernet}
\end{figure}

\subsection{Design und Coding}
In diesem Kapitel werden Attribute, Funktionen und Statecharts wichtiger Klassen im Detail vorgestellt.

\subsubsection*{Ethernet-Controller, Transmitter und Receiver}
Der Ethernet-Controller basiert auf der MDK Middleware Network Component in der Version 7.4.0. Die Network Component beinhaltet eine Vielzahl an Services, Sockets (TCP, UDP und BSD), sowie eine Ethernet Schnittstelle inklusive eines IPv4/IPv6 Protocol Stacks. In dieser Arbeit wird der BSD Socket als Datagram Socket (UDP) zusammen mit dem IPv4 Protocol Stack verwendet. Der BSD Socket stellt eine API zur Verfügung, die das Aufbauen und Abhandeln einer Netzwerkkommunikation unterstützt. Ursprünglich wurden die BSD Sockets für unixnahe Betriebssysteme entwickelt. Mittlerweile sind sie in den POSIX Standard aufgenommen und wurden auch von Microsoft Windows übernommen. Ein Vorteil der BSD Sockets ist, dass mit geringem Konfigurationsaufwand zwischen Stream Sockets (TCP) und Datagram Sockets (UDP) gewechselt werden kann. 

Die Klasse \texttt{Ether\-net\-Con\-trol\-ler} mit ihren Attributen und Operationen ist in \autoref{fig:EthernetController} dargestellt. Zum Spezifizieren der IP-Adressen dienen die Attribute \texttt{hostIpAddr} und \texttt{remoteIpAddr} vom Typ String. Die IP-Adresse werden in Rhapsody über den Features Dialog der beiden Attribute initial festgelegt. Zum Flashen des zweiten Targets können die IP-Adressen einfach getauscht werden.

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.475\textwidth]{images/EthernetController.pdf}
		\caption[EthernetController]{Basisklasse des Ethernet-Controllers mit abgeleiteten Klassen.}
	\label{fig:EthernetController}
\end{figure}

\lstset{escapechar=@, escapeinside={(*@}{@*)}, style=customcpp}
\begin{lstlisting}[caption={Konstruktor des Ethernet-Controllers}, captionpos=b, label={lst:EthernetControllerConstructor}]
unsigned char buf[8];

if (status != netOK)   
{	
	// Initialize the network component only once
	status = netInitialize (); (*@\label{netInitialize}@*)

	// Set the host ip address once
	netIP_aton (hostIpAddr, NET_ADDR_IP4, buf);
	netIF_SetOption (
		NET_IF_CLASS_ETH | 0, 
		netIF_OptionIP4_Address, 
		buf, NET_ADDR_IP4_LEN);
}
\end{lstlisting}

\autoref{lst:EthernetControllerConstructor} zeigt den Konstruktor des \texttt{Ether\-net\-Con\-trol\-lers}. Der Konstruktor verwendet ausschließlich Funktionen der Network Component, was am Prefix \texttt{net} zu erkennen ist. In Zeile \ref{netInitialize} wird die Funktion \texttt{netInitialize} aufgerufen. Diese Funktion muss bei Systemstart einmalig ausgeführt werden. Sie initialisiert Systemressourcen, Protokolle und zwei Tasks für den Network Core. Bei erfolgreicher Initialisierung wird dem Attribut \texttt{status} der Wert \texttt{netOK} zugewiesen. Mit der übergeordneten Abfrage wird sichergestellt, dass die Initialisierung auch nur einmalig durchgeführt wird, auch wenn der Konstruktor des \texttt{Ether\-net\-Con\-trol\-lers} durch die beiden Instanzen der abgeleiteten Klassen zweimal durchlaufen wird. Die Funktion \texttt{netIP\_aton} konvertiert eine IP-Adresse vom Typ String in eine binäre Form. Dadurch ist es anschließend möglich, die Host IP-Adresse dynamisch mit Hilfe der Funktion \texttt{netIF\_SetOption} zu setzen. Somit ist die Konfiguration der Host IP-Adresse ebenfalls in Rhapsody möglich und benötigt keine manuelle Anpassung innerhalb der Keil Umgebung.

Das Sequenzdiagramm in Abbildung \ref{fig:EthernetTransmitter} stellt das Verhalten des Ethernet-Transmitters dar. Der \texttt{Ether\-net\-Transmitter} erstellt in seinem Konstruktor einen Socket vom Typ Datagram Sockets (UDP), zu erkennen am Übergabeparameter \texttt{SOCK\_DGRAM}. Dem Socket weißt er durch Aufruf von \texttt{connect} die Remote IP-Adresse, also die IP-Adresse des anderen Endpunkts, zu. Aufgrund des gewählten Typ Datagram Sockets (UDP), richtet der \texttt{Ether\-net\-Transmitter} zudem ein Adressfilter zwischen den Endpunkten ein. Im weiteren Ablauf reagiert der \texttt{Ether\-net\-Transmitter} auf das Event \texttt{evNew\-Joy\-stick\-Position} welches vom Joystick abgefeuert wird. Durch die Operation \texttt{transmitData} handelt der \texttt{Ether\-net\-Transmitter} seine Sendeaktivitäten ab. Die Funktion \texttt{send} sorgt dafür, dass die Daten im Buffer \texttt{dbuf} übertragen werden und dass das Event \texttt{evBlink} die Sende-LED P1.28 blinken lässt. 

\begin{figure}%
	\centering
	\subfigure[Initialisierung und Sendeablauf des Ethernet-Transmitters.]{
					\label{fig:EthernetTransmitter}
					\includegraphics[width=1\textwidth]{images/EthernetTransmitter.pdf}
	}
	\subfigure[Initialisierung des Ethernet-Receivers und Ablauf beim Empfangen von Daten.]{
					\label{fig:EthernetReceiver}
					\includegraphics[width=1\textwidth]{images/EthernetReceiver.pdf}
	}%
	\caption[EthernetTransCeiver]{Sequenzdiagramme des Ethernet-Transmitters und -Receivers.}
	\label{fig:EthernetTransCeiver}
\end{figure}

Der \texttt{Ether\-net\-Receiver} erstellt in seinem Konstruktor ebenfalls einen Socket vom Typ Datagram Sockets (UDP) und bindet diesen mit der Funktion \texttt{bind} an die Remote IP-Adresse sowie an den Ziel-Port. Der Ziel-Port \texttt{dstPort} kann für beide Targets gleich bleiben, er definiert an welchem Port auf eingehende Datenpakete gehorcht wird. Anschließend durchläuft der \texttt{Ether\-net\-Transmitter} eine Endlosschleife. In dieser ruft er seine Operation \texttt{receiveData} auf, welche das Empfangen von Daten behandelt. Die Funktion \texttt{recv} empfängt eingehende Daten auf dem zuvor spezifizierten Port. Wenn der Network Core erkennt, dass ein Betriebssystem im Einsatz ist, betreibt der Network Core die Funktion \texttt(recv) automatisch im Blocking Mode. Dadurch ist es zwingend erforderlich, dass die Klasse \texttt{Ether\-net\-Receiver} in einem separaten Task ausgeführt wird. Der Blocking Mode ist zudem mit einem Timeout verbunden, der bei Ablauf in den Errorcode \texttt{BSD\_ERROR\_TIMEOUT} resultiert. Nach Ablauf der vorkonfigurierten Zeit von 20 Sekunden, oder falls zuvor Daten Empfangen wurden, ruft der \texttt{Ether\-net\-Receiver} die Funktion \texttt(recv) erneut auf. Hat der \texttt(Ether\-net\-Receiver) Daten Empfangen, werden diese auf ihre Gültigkeit überprüft. Dazu dient ein minimales Protokoll, dessen erstes Byte signalisiert, dass ein passendes Datenpakt vorhanden ist. Entspricht das erste Byte dem Wert 0x00, feuert der \texttt{Ether\-net\-Receiver} das Event \texttt{evBlink} an seine LED, damit die Empfangs-LED P1.29 blinkt. Zudem sendet er das Event \texttt{evReceivedData} mit dem Inhalt des zweiten Bytes an die LED-Bar, sowie an das Display. Das Verhalten des \texttt{Ether\-net\-Receiver} ist in Abbildung \ref{fig:EthernetReceiver} dargestellt.

Somit gibt es je Target einen \texttt{Ether\-net\-Transmitter} und einen \texttt{Ether\-net\-Receiver}, die in eigenen Tasks ihre Routinen durchlaufen. 

\subsubsection*{Joystick}

Der Joystick verfügt in Summe über sechs verschiedene Richtungen, von denen zunächst die vier Richtungen links, rechts, oben und unten von Interesse sind. Das Abtasten und Auslesen der Position des Joysticks erfolgte in Anlehnung an \citet{Schwerin17}. Dabei wurde die Auswertung der Joystick Position um ein Filter ergänzt, damit nur relevante und neue Positionen via Ethernet übertragen werden. Ursache dafür ist, dass der Joystick nach der Betätigung, in eine der zuvor aufgezählten Richtung, wieder in die zentrale Position zurück kehrt. Dadurch nimmt der Joystick eine für ihn neue Position ein und würde ohne Filter das Senden eines Datenpakets triggern. \autoref{lst:JoystickFilter} zeigt die Implementierung des Filters. Entspricht die Position des Joystick der mittigen Position, wird nie ein Event abgefeuert. Hat der Joystick eine andere Richtung eingenommen, feuert die Klasse \texttt{Joystick} das Event \texttt{evNewJoy\-stick\-Position} an den \texttt{Ether\-net\-Transmitter}.

Die Klasse \texttt{Joystick} hält die Position für eine Dauer von 100 Millisekunden, liest im Anschluss daran den aktuellen Wert aus dem entsprechenden Register aus und filtert diesen. Dieses Sample-and-Hold-Verhalten wurde im zugehörigen Statechart modelliert. Die Halte-Dauer kann im Konstruktor der Klasse \texttt{Joystick} angepasst werden.

\lstset{escapechar=@, escapeinside={(*@}{@*)}, style=customcpp}
\begin{lstlisting}[caption={Filter zur Auswertung der Joystick Position}, captionpos=b, label={lst:JoystickFilter}]
int position = (LPC_GPIO1->FIOPIN >> 20) & Joystick_Mask ;

// Bit 4-7 contain the position information
position = position >> 3; 

if (position == Joystick_CENTER)
{   
	// Only update the position in case the Joystick got back to the center
	lastPosition = position;  
}
else if (position != lastPosition)
{
	lastPosition = position;    	
	FIRE( this->itsEthernetTransmitter, evNewJoystickPosition(position)); 
}   
\end{lstlisting}

\subsubsection*{LED-Bar und Display}

Die LED-Bar und das Display sind die Empfänger des Events \texttt{evReceivedData}, welches der Ethernet-Receiver mit dem Inhalt des zweiten Bytes als Parameter abfeuert. Die Klasse \texttt{LedBar} ordnet den empfangenen Parameter der entsprechenden LED zu und ruft die Operation \texttt{toggleLed} der Klasse \texttt{Led} auf. Die Klasse \texttt{Display} nutzt ebenfalls den empfangenen Parameter und zeigt damit die zuletzt empfangene Richtung an.

\subsection{Konfigurieren des Keil Projekts}
Als Basis für die Implementierung wurde das Blinky-Beispielprojekt verwendet, welches im RXF \begin{itshape}Rpy\_CPP\_CMSIS\_Keil5\_ARM\_MCB1700\_TD\end{itshape} von Willert enthalten ist. Zwar ist das Keil Projekt lediglich rudimentär konfiguriert, stellt aber die funktionsfähige Einbindung von Rhapsody sicher. Im Folgenden werden die wichtigsten Anpassungen in der Konfiguration gegenübergestellt.

\subsubsection*{Manage Run-Time Environment} 

\begin{tabular}{l|ccc|ccc}
& \multicolumn{3}{ c| }{Blinky} &  \multicolumn{3}{ c }{Ethernet} \\
Software Component & Sel. & Variant & Version & Sel. & Variant & Version \\
\hline
\includegraphics[]{images/package.png} Board Support & & MCB1700 & & & MCB1700 & \\

\includegraphics[]{images/package.png} CMSIS & \cellcolor{KeilGreen} & & & \cellcolor{KeilGreen} & & \\
\hspace{3ex}\includegraphics[]{images/item.png} CORE & \cellcolor{KeilGreen}\CheckedBox  &  & 4.3.0 & \cellcolor{KeilGreen}\CheckedBox &  & 5.0.1 \\
\end{tabular}

 

