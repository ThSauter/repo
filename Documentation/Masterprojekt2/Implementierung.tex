\chapter{Implementierungen}
\section{Ethernet}\label{sec:Ethernet} 

Dieses Kapitel beschreibt die Einbindung der Ethernet Schnittstelle des Keil MCB1760 Evaluation Boards. Ziel ist es, dass zwei Boards über ihre Ethernet Schnittstelle Daten austauschen können. In der Implementierung nach \citet{Steinmeyer} wurde die gewünschte Funktionalität bereits umgesetzt, jedoch auf der Basis des RTX RL-ARM Echtzeitbetriebssystems und einer damit überholten Version der Keil MDK. Zudem soll die gesamte Implementierung in Rhapsody stattfinden, so dass der generierte Code in der IDE Keil uVision lediglich übersetzt und auf das Target geflasht werden muss. 

Zur Implementierung und Demonstration der Kommunikation über Ethernet wurde eine Entwicklungsumgebung entsprechend der nachfolgenden Abbildung aufgebaut.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth]{images/EthernetAufbau.pdf}
		\caption[Demonstrator Ethernet zwischen zwei Eval Boards]{Demonstrator für die Kommunikation zwischen zwei MCB1760 Evaluation Boards über Ethernet}
	\label{fig:DemonstratorEthernet}
\end{figure}

Wie in \autoref{fig:DemonstratorEthernet} dargestellt, sind die beiden MCB1760 Evaluation Boards über Patchkabel mit einen Hub verbunden. Der Hub hat gegenüber einem Switch oder Router den Nachteil, dass er eine geringere nutzbare Bandbreite mit sich bringt. Grund dafür ist, dass der Hub ein Datenpaket immer an jedes angeschlossene Gerät sendet, unabhängig davon, ob das Datenpaket an das Gerät adressiert wurde oder nicht. Jedoch unterstützt dieses Defizit bei der Implementierung, indem mit Hilfe eines PCs das Tool Wireshark den Datenverkehr zwischen den beiden MCB1760 Evaluation Boards abhört. Da die versendeten Datenpakete eine Größe von zwei Bytes haben, spielt die nutzbare Bandbreite im Rahmen dieser Arbeit keine Rolle. 

\subsection{Anforderungen}\label{subsec:Anforderungen} 

Zur Demonstration einer funktionsfähigen Ethernet-Kommunikation soll ein exemplarisches Szenario implementiert werden. So sollen LEDs durch den Joystick auf dem jeweils anderen Board ein- und ausgeschaltet werden. Dabei soll die Position des Joysticks angeben, welche LED die LED-Bar ein- oder ausschaltet. Des Weiteren soll das Display die zuletzt empfangene Position anzeigen. Damit die MCB1760 Evaluation Boards einfach zu identifizieren sind, soll das Display zudem die Host IP Adresse sowie die Target IP Adresse darstellen. Beim Senden sowie beim Empfangen eines Datenpakets soll der Transmitter bzw. der Receiver kurzzeitig eine LED blinken lassen. Die Zuordnung von Funktionen zu den LEDs der LED-Bar ist \autoref{fig:Szenario} rechts dargestellt. 

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth]{images/Szenario.pdf}
		\caption[Beispiel mit Zuordnung der LEDs]{Beispiel mit Zuordnung der LEDs.}
	\label{fig:Szenario}
\end{figure}

Zudem veranschaulicht \autoref{fig:Szenario} das Funktionsprinzip. Auf dem Host MCB1760 Evaluation Board bewegt der Benutzer den Joystick in die linke Richtung. Das führt dazu, dass beim Remote MCB1760 Evaluation Board die Receiver LED P1.29 kurzzeitig aufleuchtet, sowie die LED P2.3 dauerhaft angeschaltet wird. Bewegt der Benutzer den Joystick erneut in die linke Richtung, erlischt die LED P2.3 wieder.

\subsection{Architektur}
Bei der Formulierung der Anforderungen in \autoref{subsec:Anforderungen} wurde darauf geachtet, dass diese in möglichst aktiver Form spezifiziert sind. Dadurch können die benötigten Klassen abgeleitet werden, welches sich im Folgenden durch die Ähnlichkeit von Subjekten oder Objekten zu den Klassennamen widerspiegelt.

Die Architektur der Ethernet-Kommunikation ist als Klassendiagramm in \autoref{fig:ClassDiagramEthernet} dargestellt. Zentrales Element ist die Basisklasse \texttt{Ether\-net\-Con\-trol\-ler}, von ihr werden die beiden Klassen \texttt{Ether\-net\-Transmitter} und \texttt{Ether\-net\-Receiver} abgeleitet. Diese beiden Klassen arbeiten in separaten Tasks und sind für das Senden und Empfangen von Datenpaketen verantwortlich. Auf der linken Seite in \autoref{fig:ClassDiagramEthernet} sind die Klassen \texttt{Running\-Indicator\-Led} und \texttt{Joystick} abgebildet, welche ebenfalls in eigenen Tasks ausgeführt werden. Die Klasse \texttt{Running\-Indicator\-Led} lässt die LED P1.31 zyklisch blinken, mit einer Periodendauer von einer Sekunde. Sie dient zu Debugging zwecken und um unmittelbar zu erkennen, ob das Target läuft. Die Klasse \texttt{Joystick} pollt regelmäßig die Position des Joysticks. Auf der rechten Seite sind die Klassen \texttt{LedBar}, \texttt{Display} und \texttt{Led} zu finden. Dabei liegt zwischen den Klassen \texttt{LedBar} und \texttt{Led} eine Komposition mit der Multiplizität vier vor, wodurch der LED-Bar die LEDs zugeordnet sind, welche eine Joystick Position repräsentieren. Außerhalb des Pakets \texttt{DefaultPkg} sind Abhängigkeiten zu externen Bibliotheken in orange eingezeichnet. Die verwendeten Bibliotheken, Network und Graphics Component, stammen aus der MDK Middleware und vereinfachen das Verwenden dieser Peripheriegeräte. Mögliche Vorgehensweisen beim Einbinden externer Quellen beschreiben \citet{ExternalSources}.

\begin{figure}[h!]
	\centering
		\includegraphics[width=1\textwidth]{images/ClassDiagramEthernet.pdf}
		\caption{Klassendiagramm zur Ethernet-Kommunikation. Klassen, die in eigenen Tasks laufen sind rot eingezeichnet.}
	\label{fig:ClassDiagramEthernet}
\end{figure}

\subsection{Design und Coding}\label{subsec:DesignUndCoding}
In diesem Kapitel werden Attribute, Funktionen und Statecharts wichtiger Klassen im Detail vorgestellt.

\subsubsection*{Ethernet-Controller, Transmitter und Receiver}
Der Ethernet-Controller basiert auf der MDK Middleware Network Component in der Version 7.4.1. Die Network Component beinhaltet eine Vielzahl an Services, Sockets (TCP, UDP und BSD), sowie eine Ethernet Schnittstelle inklusive eines IPv4/IPv6 Protocol Stacks. In dieser Arbeit wird der BSD Socket als Datagram Socket (UDP) zusammen mit dem IPv4 Protocol Stack verwendet. Der BSD Socket stellt eine API zur Verfügung, die das Aufbauen und Abhandeln einer Netzwerkkommunikation unterstützt. Ursprünglich wurden die BSD Sockets für unixnahe Betriebssysteme entwickelt. Mittlerweile sind sie in den POSIX Standard aufgenommen und wurden auch von Microsoft Windows übernommen. Ein Vorteil der BSD Sockets ist, dass mit geringem Konfigurationsaufwand zwischen Stream Sockets (TCP) und Datagram Sockets (UDP) gewechselt werden kann. 

Die Klasse \texttt{Ether\-net\-Con\-trol\-ler} mit ihren Attributen und Operationen ist in \autoref{fig:EthernetController} dargestellt. Zum Spezifizieren der IP-Adressen dienen die Attribute \texttt{hostIpAddr} und \texttt{remoteIpAddr} vom Typ String. Die IP-Adresse werden in Rhapsody über den Features Dialog der beiden Attribute initial festgelegt. Zum Flashen des zweiten Targets können die IP-Adressen einfach getauscht werden.

\begin{figure}[h!]
	\centering
		\includegraphics[width=0.49\textwidth]{images/EthernetController.pdf}
		\caption{Basisklasse des Ethernet-Controllers mit abgeleiteten Klassen.}
	\label{fig:EthernetController}
\end{figure}

\lstset{escapechar=@, escapeinside={(*@}{@*)}, style=customcpp}
\begin{lstlisting}[caption={Konstruktor des Ethernet-Controllers}, label={lst:EthernetControllerConstructor}, captionpos=b]
unsigned char buf[8];

if (status != netOK)   
{	
	// Initialize the network component only once
	status = netInitialize (); (*@\label{netInitialize}@*)

	// Set the host ip address once
	netIP_aton (hostIpAddr, NET_ADDR_IP4, buf);
	netIF_SetOption (
		NET_IF_CLASS_ETH | 0, 
		netIF_OptionIP4_Address, 
		buf, 
		NET_ADDR_IP4_LEN);
}
\end{lstlisting}

\autoref{lst:EthernetControllerConstructor} zeigt den Konstruktor des \texttt{Ether\-net\-Con\-trol\-lers}. Der Konstruktor verwendet ausschließlich Funktionen der Network Component, was am Prefix \texttt{net} zu erkennen ist. In \autoref{netInitialize} wird die Funktion \texttt{netInitialize} aufgerufen. Diese Funktion muss bei Systemstart einmalig ausgeführt werden. Sie initialisiert Systemressourcen, Protokolle und zwei Tasks für den Network Core. Bei erfolgreicher Initialisierung wird dem Attribut \texttt{status} der Wert \texttt{netOK} zugewiesen. Mit der übergeordneten Abfrage wird sichergestellt, dass die Initialisierung auch nur einmalig durchgeführt wird, auch wenn der Konstruktor des \texttt{Ether\-net\-Con\-trol\-lers} durch die beiden Instanzen der abgeleiteten Klassen zweimal durchlaufen wird. Die Funktion \texttt{netIP\_aton} konvertiert eine IP-Adresse vom Typ String in eine binäre Form. Dadurch ist es anschließend möglich, die Host IP-Adresse dynamisch mit Hilfe der Funktion \texttt{netIF\_SetOption} zu setzen. Somit ist die Konfiguration der Host IP-Adresse ebenfalls in Rhapsody möglich und benötigt keine manuelle Anpassung innerhalb der Keil Umgebung.

Das Sequenzdiagramm in \autoref{fig:EthernetTransmitter} stellt das Verhalten des Ethernet-Transmitters dar. Der \texttt{Ether\-net\-Transmitter} erstellt in seinem Konstruktor einen Socket vom Typ Datagram Sockets (UDP), zu erkennen am Übergabeparameter \texttt{SOCK\_DGRAM}. Dem Socket weißt er durch Aufruf von \texttt{connect} die Remote IP-Adresse, also die IP-Adresse des anderen Endpunkts, zu. Aufgrund des gewählten Typ Datagram Sockets (UDP), richtet der \texttt{Ether\-net\-Transmitter} zudem ein Adressfilter zwischen den Endpunkten ein. Im weiteren Ablauf reagiert der \texttt{Ether\-net\-Transmitter} auf das Event \texttt{evNew\-Joy\-stick\-Position} welches vom Joystick abgefeuert wird. Durch die Operation \texttt{tran\-smit\-Data} handelt der \texttt{Ether\-net\-Transmitter} seine Sendeaktivitäten ab. Die Funktion \texttt{send} sorgt dafür, dass die Daten im Buffer \texttt{dbuf} übertragen werden und dass das Event \texttt{evBlink} die Sende-LED P1.28 blinken lässt. 

\begin{figure}
	\centering
	\subfigure[Initialisierung und Sendeablauf des Ethernet-Transmitters.]{
					\label{fig:EthernetTransmitter}
					\includegraphics[width=1\textwidth]{images/EthernetTransmitter.pdf}
	}
	\subfigure[Initialisierung des Ethernet-Receivers und Ablauf beim Empfangen von Daten.]{
					\label{fig:EthernetReceiver}
					\includegraphics[width=1\textwidth]{images/EthernetReceiver.pdf}
	}
	\caption{Sequenzdiagramme des Ethernet-Transmitters und -Receivers.}
	\label{fig:EthernetTransCeiver}
\end{figure}

Der \texttt{Ether\-net\-Receiver} erstellt in seinem Konstruktor ebenfalls einen Socket vom Typ Datagram Sockets (UDP) und bindet diesen mit der Funktion \texttt{bind} an die Remote IP-Adresse sowie an den Ziel-Port. Der Ziel-Port \texttt{dstPort} kann für beide Targets gleich bleiben, er definiert an welchem Port auf eingehende Datenpakete gehorcht wird. Anschließend durchläuft der \texttt{Ether\-net\-Transmitter} eine Endlosschleife. In dieser ruft er seine Operation \texttt{receiveData} auf, welche das Empfangen von Daten behandelt. Die Funktion \texttt{recv} empfängt eingehende Daten auf dem zuvor spezifizierten Port. Wenn der Network Core erkennt, dass ein Betriebssystem im Einsatz ist, betreibt der Network Core die Funktion \texttt(recv) automatisch im Blocking Mode. Dadurch ist es zwingend erforderlich, dass die Klasse \texttt{Ether\-net\-Receiver} in einem separaten Task ausgeführt wird. Der Blocking Mode ist zudem mit einem Timeout verbunden, der bei Ablauf in den Errorcode \texttt{BSD\_ERROR\_TIMEOUT} resultiert. Nach Ablauf der vorkonfigurierten Zeit von 20 Sekunden, oder falls zuvor Daten Empfangen wurden, ruft der \texttt{Ether\-net\-Receiver} die Funktion \texttt(recv) erneut auf. Hat der \texttt(Ether\-net\-Receiver) Daten Empfangen, werden diese auf ihre Gültigkeit überprüft. Dazu dient ein minimales Protokoll, dessen erstes Byte signalisiert, dass ein passendes Datenpakt vorhanden ist. Entspricht das erste Byte dem Wert 0x00, feuert der \texttt{Ether\-net\-Receiver} das Event \texttt{evBlink} an seine LED, damit die Empfangs-LED P1.29 blinkt. Zudem sendet er das Event \texttt{evReceivedData} mit dem Inhalt des zweiten Bytes an die LED-Bar, sowie an das Display. Das Verhalten des \texttt{Ether\-net\-Receiver} ist in \autoref{fig:EthernetReceiver} dargestellt.

Somit gibt es je Target einen \texttt{Ether\-net\-Transmitter} und einen \texttt{Ether\-net\-Re\-cei\-ver}, die in eigenen Tasks ihre Routinen durchlaufen. 

\subsubsection*{Joystick}

Der Joystick verfügt in Summe über sechs verschiedene Richtungen, von denen zunächst die vier Richtungen links, rechts, oben und unten von Interesse sind. Das Abtasten und Auslesen der Position des Joysticks erfolgte in Anlehnung an \citet{Schwerin17}. Dabei wurde die Auswertung der Joystick Position um ein Filter ergänzt, damit nur relevante und neue Positionen via Ethernet übertragen werden. Ursache dafür ist, dass der Joystick nach der Betätigung, in eine der zuvor aufgezählten Richtung, wieder in die zentrale Position zurück kehrt. Dadurch nimmt der Joystick eine für ihn neue Position ein und würde ohne Filter das Senden eines Datenpakets triggern. \autoref{lst:JoystickFilter} zeigt die Implementierung des Filters. Bewegt sich der Joystick in die mittige Position, wird nie ein Event abgefeuert. Hat der Joystick eine andere Richtung eingenommen, feuert die Klasse \texttt{Joystick} das Event \texttt{evNewJoy\-stick\-Position} an den \texttt{Ether\-net\-Transmitter}.

Die Klasse \texttt{Joystick} hält die Position für eine Dauer von 100 Millisekunden, liest im Anschluss daran den aktuellen Wert aus dem entsprechenden Register aus und filtert diesen. Dieses Sample-and-Hold-Verhalten wurde im zugehörigen Statechart modelliert. Die Halte-Dauer kann im Konstruktor der Klasse \texttt{Joystick} angepasst werden.

\lstset{escapechar=@, escapeinside={(*@}{@*)}, style=customcpp}
\begin{lstlisting}[caption={Filter zur Auswertung der Joystick Position}, captionpos=b, label={lst:JoystickFilter}]
int position = (LPC_GPIO1->FIOPIN >> 20) & Joystick_Mask ;

// Bit 4-7 contain the position information
position = position >> 3; 

if (position == Joystick_CENTER)
{   
	// If the Joystick got back to center only update
	lastPosition = position;  
}
else if (position != lastPosition)
{
	lastPosition = position;    	
	FIRE( this->itsEthernetTransmitter, evNewJoystickPosition(position)); 
}   
\end{lstlisting}

\subsubsection*{LED-Bar und Display}

Die LED-Bar und das Display sind die Empfänger des Events \texttt{evReceivedData}, welches der Ethernet-Receiver mit dem Inhalt des zweiten Bytes als Parameter abfeuert. Die Klasse \texttt{LedBar} ordnet den empfangenen Parameter der entsprechenden LED zu und ruft die Operation \texttt{toggleLed} der Klasse \texttt{Led} auf. Die Klasse \texttt{Display} nutzt ebenfalls den empfangenen Parameter und zeigt damit die zuletzt empfangene Richtung an.

\subsection{Konfigurieren des Keil Projekts}

Als Basis für die Implementierung wurde das Blinky-Beispielprojekt verwendet, welches im RXF \textit{Rpy\_CPP\_CMSIS\_Keil5\_ARM\_MCB1700\_TD} von Willert enthalten ist. Zwar ist das Keil Projekt lediglich rudimentär konfiguriert, stellt aber die funktionsfähige Einbindung von Rhapsody sicher. Im Folgenden werden die wichtigsten Anpassungen in der Konfiguration gegenübergestellt.

\subsubsection*{Manage Run-Time Environment} 

Mittels des Konfigurationsassistenten \includegraphics[width=0.3cm]{images/package.pdf} \textit{Manage Run"=Time Environment} ist es möglich, Software Komponenten einem Keil Projekt hinzuzufügen. Mit dem Ziel eine Ethernet Kommunikation aufzubauen, wird zunächst der Software Pack \textit{Keil::MDK"=Middleware} in der Version 7.4.1 (2017-04-21) dem Projekt hinzugefügt. Diese Paket beinhaltet unter anderem die Network Component in der Version 7.5.0 (2017-04-21). Zum Betreiben der Network Component wird der \textit{ARM::CMSIS:CORE} in der Version 5.0.1 vorausgesetzt. Die dazu notwendige Änderung im Ethernet Projekt gegenüber dem Blinky Projekt ist in \autoref{tab:RuntimeEnv} rot gekennzeichnet.

Die Network Component beinhaltet eine Vielzahl an Komponenten, die dem Keil Projekt hinzugefügt werden können. Für den vorliegenden Fall der Ethernet"=Kommunikation sind die Komponenten und die benötigten CMSIS Treiber gemäß \autoref{tab:RuntimeEnv} zu wählen. Notwendige Anpassungen zur Verwendung des Displays sind orange markiert.

\begin{table}[!ht]
\centering
\footnotesize
\begin{tabular}{p{0.01mm}p{4.6cm}p{0.2cm}p{2.2cm}lp{0.2cm}p{2.2cm}l}
	\toprule
	& & \multicolumn{3}{ c }{Blinky} & \multicolumn{3}{ c }{Ethernet} \\ \cmidrule{3-5}  \cmidrule{6-8}
	& Software Component & Sel. & Variant & Version & Sel. & Variant & Version \\
	\midrule
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Board Support & & \tiny{MCB1700} & & \cellcolor{KeilGreen} & \tiny{MCB1700} & \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Graphic LCD (API) &  &  & 1.0.0 & \cellcolor{KeilGreen} &  & 1.0.0 \\
	\textcolor{Orange}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFii\textSFx\textSFx	\includegraphics[width=0.2cm]{images/item.pdf} Graphic LCD & \HollowBox &  & 1.0.0 & \cellcolor{KeilGreen}\CheckedBox &  & 5.0.1 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} CMSIS & \cellcolor{KeilGreen} & & & \cellcolor{KeilGreen} & & \\
	\textcolor{Red}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFii\textSFx\textSFx	\includegraphics[width=0.2cm]{images/item.pdf} CORE & \cellcolor{KeilGreen}\CheckedBox  &  & 4.3.0 & \cellcolor{KeilGreen}\CheckedBox &  & 5.0.1 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} CMSIS Driver & & & & \cellcolor{KeilGreen} & & \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Ethernet MAC (API) & & & 2.01 & \cellcolor{KeilGreen} &  & 2.1.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} Ethernet MAC & \HollowBox  &  & 2.9 & \cellcolor{KeilGreen}\CheckedBox &  & 2.9.0 \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Ethernet PHY (API) & & & 2.00 & \cellcolor{KeilGreen} &  & 2.1.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} DP83848C & \HollowBox  &  & 6.1 & \cellcolor{KeilGreen}\CheckedBox &  & 6.1.0 \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} SPI (API) & & & 2.01 & \cellcolor{KeilGreen} &  & 2.2.0 \\
	& \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} SPI & \HollowBox  &  & 2.1 & \HollowBox &  & 2.1.0 \\
	\textcolor{Orange}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{5ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} SSP & \HollowBox  &  & 2.5 & \cellcolor{KeilGreen}\CheckedBox &  & 2.7.0 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Device & & & & \cellcolor{KeilGreen} & & \\
	\textcolor{Orange}{ \pmboxdrawuni{258E}}
 & \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} GPDMA & \HollowBox &  & 1.2 & \cellcolor{KeilGreen}\CheckedBox &  & 1.2.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} GPIO & \HollowBox &  & 1.1 & \cellcolor{KeilGreen}\CheckedBox &  & 1.1.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} PIN & \HollowBox &  & 1.0 & \cellcolor{KeilGreen}\CheckedBox &  & 1.0.0 \\
	& \textSFxi\hspace{2ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} Startup & \cellcolor{KeilGreen}\CheckedBox &  & 1.0.0 & \cellcolor{KeilGreen}\CheckedBox &  & 1.0.0 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Network & & \tiny{MDK-Pro} & 7.4.0 & \cellcolor{KeilGreen} & \tiny{MDK-Pro} & 7.5.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{3.2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} CORE & \HollowBox & \tiny{IPv4/IPv6 Release} & 7.4.0 & \cellcolor{KeilGreen}\CheckedBox & \tiny{IPv4/IPv6 Release} & 7.5.0 \\
	& \hspace{3.2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} Legacy API & \HollowBox &  & 7.4.0 & \HollowBox &  & 7.5.0 \\
	& \hspace{3.2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Interface & & & & \cellcolor{KeilGreen} &  & \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/items.pdf} ETH & 0  &  & 7.4.0 & \cellcolor{KeilGreen} 1 &  & 7.5.0 \\
	& \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} PPP & \HollowBox &  & 7.4.0 & \HollowBox &  & 7.5.0 \\
	& \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} SLIP & \HollowBox &  & 7.4.0 & \HollowBox &  & 7.5.0 \\
	& \hspace{3.2ex}$\boxplus$\textSFx\includegraphics[width=0.25cm]{images/package.pdf} Service & & & & & & \\
	& \hspace{3.2ex}$\boxminus$\textSFx\includegraphics[width=0.25cm]{images/package.pdf} Socket & & & & \cellcolor{KeilGreen} & & \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{6.3ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} BSD & \HollowBox &  & 7.4.0 & \cellcolor{KeilGreen}\CheckedBox &  & 7.5.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{6.3ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} TCP & \HollowBox &  & 7.4.0 & \cellcolor{KeilGreen}\CheckedBox &  & 7.5.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{6.3ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} UDP & \HollowBox &  & 7.4.0 & \cellcolor{KeilGreen}\CheckedBox &  & 7.5.0 \\
	\bottomrule
\end{tabular}
\caption{Heraufsetzen des CMSIS:CORE (rot), benötigte Komponenten der Network Component und deren Abhängigkeiten (gelb), sowie die Komponenten zum Betreiben des Displays (orange).}
\label{tab:RuntimeEnv}
\end{table}

\subsubsection*{Target Options}

Mit der Aufnahme der Network Component in das Keil Projekt, steigt der erforderliche RAM-Speicherbedarf der Applikation auf über 41KB (RW-data=352 Bytes + ZI-data=41176 Bytes). Damit wird die vorkonfigurierte RAM-Speichergröße von 32KB überschritten. Jedoch verfügt das Keil MCB1760 Evaluation Board über insgesamt 64KB RAM On-Chip Memory, so dass die weiteren 32KB RAM mit Hilfe des Scatter Files adressiert werden müssen. Das Scatter File (.sct) befindet sich im Flash-Ordner des Keil-Projekts. Allerdings bietet Keil die Möglichkeit, dass Scatter File über die Bedienoberfläche zu generieren, so dass das Scatter File nicht direkt editiert werden muss. Über die \begin{itshape}Target Options\end{itshape} im Reiter \begin{itshape}Target\end{itshape} können im Panel \begin{itshape}Read/Write Memory Areas\end{itshape} die zweiten 32KB RAM-Speicher aktiviert werden. Die Startadresse der zweiten Speicherbank ist mit 0x2007C000 anzugeben, die Größe des Speichers von 32KB ebenfalls als hexadezimaler Wert mit 0x8000.

\subsubsection*{CMSIS Configuration}

Bei der CMSIS Configuration geht es primär um das Konfigurieren des CMSIS RTX Kernel. Dabei wird die Datei \textit{RTX\_Conf\_CM.c}, die Teil der CMSIS Component ist, editiert. Keil bietet den Komfort, die Datei über den integrierten \begin{itshape}Configuration Wizard\end{itshape} zu bearbeiten. Der erste Parameter \textit{Number of concurrent running user threads} im Abschnitt \textit{Thread Configuration} gibt die Anzahl der Tasks an, die zur gleichen Zeit laufen. Die Tasks mit der Ursache CMSIS-RTOS in Tabelle \autoref{tab:DefaultThreads} sind bei jeder Applikation standardmäßig aktiv, die das CMSIS-RTOS verwenden.

\begin{table}[!b]
\centering
\footnotesize
	\begin{tabular}{lcl}
	\toprule
	Task Name & Priorität & Ursache \\
	\midrule
	osTimerThread & 1 & CMSIS-RTOS \\
	main & 2 & CMSIS-RTOS \\
	os\_idle\_demon & 255 & CMSIS-RTOS \\
	WST\_\-Monitor\_receiveTask & 3 & Willert RXF \\
	netCore\_Thread & 4 & Network Component \\
	netETH\_Thread & 5 & Network Component \\
	RunningIndicator & 6 & Ethernet Applikation \\
	EthernetReceiver & 7 & Ethernet Applikation \\
	EthernetTransmitter & 8 & Ethernet Applikation \\
	Joystick & 9 & Ethernet Applikation \\
	\bottomrule
	\end{tabular}
\caption{Verwendete Task für die Ethernet-Kommunikation und deren Ursache.}
\label{tab:DefaultThreads}
\end{table}

Das Willert RXF bringt durch sein kleines Onboard-Betriebssystem mit \textit{WST\_""Monitor\_""receiveTask} einen weiteren Task mit sich. Zudem beansprucht die Network Component bei der Initialisierung die beiden Tasks \textit{netCore\_Thread} und \begin{itshape}netETH\_Thread\end{itshape}. Zusätzlich kommen noch die Tasks hinzu, die durch die Applikation an sich gefordert sind. Gemäß der in rot gekennzeichneten Klassen in \autoref{fig:ClassDiagramEthernet} sind das die Tasks \textit{RunningIndicator}, \textit{EthernetReceiver}, \textit{EthernetTransmitter} und \textit{Joystick}. In Summe ergeben sich somit zehn Tasks. Da nach \citet{CmsisRtos2017} der Task \textit{os\_idle\_demon} nicht in die Anzahl der gleichzeitig laufenden Tasks mit eingeht, wird der Parameter \textit{Number of concurrent running user threads} auf den Wert neun gesetzt. 

Unter den weiteren Parametern im Abschnitt \textit{Thread Configuration} ist vor allem der Parameter \textit{Total stack size [bytes] for threads with user-provided stack size} von Interesse.  Dieser muss im Vergleich zum Blinky Projekt um 1024 Bytes für den Task \textit{netCore\_Thread} erhöht werden, sowie um weitere 512 Bytes für den Task \textit{netEth\_Thread} \parencite{NetworkComponent2017}. Die Anpassungen für die Ethernet"=Kommunikation in der Datei \textit{RTX\_Conf\_CM.c} gegenüber dem Blinky Projekt sind in \autoref{tab:RtxConfig} aufgelistet.

\begin{table}[!ht]
\footnotesize
\centering
	\begin{tabular}{p{7.6cm}p{3.0cm}p{3.0cm}}
	\toprule
	& Blinky & Ethernet \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxminus$\textSFx Thread Configuration & &  \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Number of concurrent running user threads & 6 & 9 (+3) \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Default Thread stack size [bytes] & 200 & 200 \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Main Thread stack size [bytes] & 1024 & 1024 \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Number of threads with user-provided & 5 & 5 \\
	\textSFxi\hspace{2ex}\textSFxi \hspace{1.5ex} stack size &  & \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Total stack size [bytes] for threads with & 4096 & 5632 (+1536)\\
	\textSFxi\hspace{2ex}\textSFxi \hspace{1.5ex} user-provided stack size &  & \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx  Check for stack overflow & \CheckedBox &  \CheckedBox \\
	\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx  Processor mode for thread execution & Privileged mode & Privileged mode \\
	$\boxplus$\textSFx RTX Kernel Timer Tick Configuration & & \\
	$\boxplus$\textSFx System Configuration & & \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der RTX Configuration \textit{RTX\_Conf\_CM.c}.}
\label{tab:RtxConfig}
\end{table}

\subsubsection*{Device Configuration}

Die Datei \textit{startup\_LPC17xx.s (Startup)} bildet zusammen mit der Datei \textit{startup\_LPC17xx.c (Startup)} den Start-up Code, welcher direkt nach einem RESET des Targets ausgeführt wird. Die beiden Dateien sind Teil der Device Component und können ebenfalls über den \textit{Configuration Wizard} bearbeitet werden. Von größerem Interesse ist die Datei \textit{startup\_LPC17xx.s (Startup)} bei die Zuordnung von Speicher erfolgt. In der Datei \textit{startup\_LPC17xx.c (Startup)} geht es im Wesentlichen um die Clock Konfiguration, welche aber bei ihrer Standardeinstellung belassen wird.

Nach \citet{NetworkComponent2017} ist bei Verwendung des Ethernet Cores eine Vergößerung der Stack Size um 512 Bytes erforderlich. Eine Anpassung des Heaps ist nicht erforderlich, da in dieser Implementierung die Security Komponente nicht verwendet wird. Die Änderung im Startup File ist in \autoref{tab:StartupConfig} dargestellt.

\begin{table}[!ht]
\footnotesize
\centering
	\begin{tabular}{p{7.6cm}p{3.0cm}p{3.0cm}}
	\toprule
	& Blinky & Ethernet \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxminus$\textSFx Stack Configuration & &  \\
	\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx Stack Size (in Bytes) & 0x0000 0200 & 0x0000 0400 (+512) \\
	$\boxminus$\textSFx Heap Configuration & & \\
  \hspace{3ex}\textSFii\textSFx\textSFx Heap Size (in Bytes) & 0x0000 1000 & 0x0000 1000 \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der Startup Configuration \textit{startup\_LPC17xx.s (Startup)} für die Ethernet-Kommunikation.}
\label{tab:StartupConfig}
\end{table}

\subsubsection*{Ethernet Network Configuration}

Die Ethernet-Konfiguration erfolgt über die Konfigurationsdateien, die zur Network Component gehören. Dabei ist in Konfigurationsdatei \textit{Net\_Config\_ETH\_0.h (Interface:ETH)} eine Anpassung vorzunehmen, welche die Option \textit{Dynamic Host Configuration} betrifft. Wenn diese Option aktiviert ist, werden IP-Adresse, Netzmaske und Standardgateway automatisch von einem DHCP Server bezogen. Da der Demonstrationsaufbau über keinen DHCP Server verfügt und die IP-Adressen statisch vergeben werden, muss diese Option deaktiviert werden. \autoref{tab:EthernetNetworkConfig} zeigt, dass die IP-Adresse in dieser Datei auch manuell konfiguriert werden kann. Jedoch wird diese Option zur Laufzeit überschrieben, da die Implementierungen beschrieben in \autoref{subsec:DesignUndCoding} die IP-Adresse festlegen.
 
\begin{table}[!ht]
\footnotesize
\centering
	\begin{tabular}{p{7.6cm}p{3.0cm}p{3.0cm}}
	\toprule
	& Blinky & Ethernet \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxminus$\textSFx Ethernet Network Interface 0 & &  \\
	\hspace{3ex}\textSFviii\textSFx\textSFx Connected to hardware via Driver\_ETH\# & 0 & 0 \\
	\hspace{3ex}\textSFviii\textSFx\textSFx MAC Address & 1E-30-6C-A2-45-5E & 1E-30-6C-A2-45-5E \\
	\hspace{3ex}$\boxminus$\textSFx IPv4 & \CheckedBox & \CheckedBox \\
  \hspace{3ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx IP Address & 192.168.0.100 & 192.168.0.100 \\
	\hspace{3ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Subnet Mask & 255.255.255.0 & 255.255.255.0 \\
	\hspace{3ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Default Gateway & 192.168.0.254 & 192.168.0.254 \\
	\hspace{3ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Primary DNS Server & 8.8.8.8 & 8.8.8.8 \\	
	\hspace{3ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Secondary DNS Server & 8.8.4.4 & 8.8.4.4 \\
	\hspace{3ex}\textSFxi\hspace{2ex}$\boxplus$\textSFx IP Fragmentation & \CheckedBox & \CheckedBox \\
	\hspace{3ex}\textSFxi\hspace{2ex}$\boxplus$\textSFx ARP Adress Resolution & & \\
	\hspace{3ex}\textSFxi\hspace{2ex}$\boxplus$\textSFx IGMP Group Management & \HollowBox & \HollowBox \\
	\hspace{3ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx NetBIOS Name Service & \CheckedBox & \CheckedBox \\
	\hspace{3ex}\textSFxi\hspace{2ex}$\boxplus$\textSFx Dynamic Host Configuration & \CheckedBox & \HollowBox \\
	\hspace{3ex}$\boxplus$\textSFx IPv6 & \CheckedBox & \CheckedBox \\
	\hspace{3ex}$\boxplus$\textSFx OS Resource Settings & & \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der Ethernet Network Configuration \textit{Net\_Config\_ETH\_0.h}.}
\label{tab:EthernetNetworkConfig}
\end{table}

\section{SD-Karte}

Im Fokus dieses Kapitels steht die Inbetriebnahme des SD-Karten Slots des Keil MCB1760 Evaluation Boards. Der Schacht für die microSD-Karte befindet sich unterhalb des Displays, wie \autoref{fig:MCB1760EvalBoard} zu entnehmen ist. Das Ziel der Inbetriebnahme ist es, beispielhaft Daten auf die SD-Karte zu schreiben, lesen und diese wieder zu löschen. Wie auch schon bei der Ethernet-Applikation in \autoref{sec:Ethernet} soll die Implementierung in Rational Rhapsody erfolgen und die IDE Keil uVision lediglich zum Übersetzen und Flashen dienen.

\subsection{Anforderungen}

Ein beispielhaftes Szenario soll die funktionsfähige Inbetriebnahme der SD-Karte demonstrieren. Dabei soll der Joystick bei Betätigung in eine Richtung seine neue Position auf der SD-Karte aufzeichnen. Unter einer Positionsänderung des Joysticks sind die vier Richtungen links, rechts, oben und unten zu verstehen. Wenn der Joystick nach einer Richtungsänderung zurück in die zentrale Position geht, wird das nicht als Positionsänderung gewertet. Die SD-Karte soll sämtliche Aktivitäten und ihren Status über das Display ausgeben. \autoref{fig:SDCardSzenario} veranschaulicht das Funktionsprinzip. 
\begin{figure}[!hb]
	\centering
		\includegraphics[width=1\textwidth]{images/SDCardSzenario.pdf}
		\caption{Beispielhaftes Logging der Joystick Position auf dem Display und auf der SD-Karte.}
	\label{fig:SDCardSzenario}
\end{figure}

Zusätzlich ist es möglich, auf den Joystick zu drücken, was im Folgenden als Richtung \textit{SELECT} bezeichnet wird. Die Richtung \textit{SELECT} soll eine besondere Funktion im Beispielszenario einnehmen. Drückt der Benutzer den Joystick zweimal hintereinander, dann soll die SD-Karte die angelegte Log-Datei löschen. Bei erstmaligem Drücken soll die SD-Karte dem Benutzer über das Display mitteilen, dass die SD-Karte durch erneutes Drücken des Joysticks die angelegte Log-Datei löscht. Wählt der Benutzer jedoch eine andere Richtung, soll die SD-Karte wieder in den Log-Status zurückkehren. Ebenso soll die SD-Karte eine minimale Fehlerbehandlung enthalten und dem Benutzer über das Display entsprechende Fehlermeldungen anzeigen.

Zur Verifizierung der Lesefunktion soll die SD-Karte überprüfen, ob bereits eine Log-Datei durch vorherige Verwendung angelegt wurde. Wenn das der Fall ist, soll die SD-Karte die letzte Zeile der Log-Datei auslesen, die fortlaufende Nummer extrahieren und den Zähler auf diesen Wert setzen. 

\subsection{Architektur}

Das Klassendiagramm in \autoref{fig:ClassDiagramSDCard} stellt die Architektur des SD-Karten Loggings dar. Im Fokus des Diagramms steht die Klasse \texttt{SDCard}. Sie besitzt eine gerichtete Assoziation zur Klasse \texttt{Clock} und zur Klasse \texttt{Display}. Dadurch kann die Klasse \texttt{SDCard} einen Zeitstempel abfragen und den aktuellen Status auf dem Display ausgeben. 

\begin{figure}[!b]
	\centering
		\includegraphics[width=1\textwidth]{images/ClassDiagramSDCard.pdf}
		\caption{Klassendiagramm zum Logging der Joystick Positionen auf der SD-Karte. Klassen, die in eigenen Threads laufen sind rot eingezeichnet.}
	\label{fig:ClassDiagramSDCard}
\end{figure}

In \autoref{fig:ClassDiagramSDCard} links dargestellt sind beiden Klassen \texttt{Jostick} und \texttt{Running\-Indicator\-Led}, welche in eigenen Threads laufen. Dabei verfügt die Klasse \texttt{Jostick} über eine gerichtete Assoziation zur Klasse \texttt{SDCard}. Somit kann die Klasse \texttt{Joystick}, welche in einem festgelegten Intervall die Joystick Position pollt, die Klasse \texttt{SDCard} über Positionsänderungen informieren. Die Klasse \texttt{Joystick} verfügt über eine weitere Assoziation zur Klasse \texttt{LedBar}, wodurch die Joystick Position mit Hilfe von vier LEDs visualisiert wird. Wie in den vorherigen Implementierungen lässt die Klasse \texttt{Running\-Indicator\-Led} die LED P1.31 zyklisch blinken und dient lediglich zu Debugging zwecken. Die in \autoref{fig:ClassDiagramSDCard} rechts in orange dargestellten Dateien außerhalb des Pakets \texttt{DefaultPkg} stellen Abhängigkeiten zu externen Bibliotheken dar. Die verwendeten Bibliotheken stammen aus der MDK Middleware und vereinfachen das Betreiben der File System und Graphics Component.

\subsection{Design und Coding}

Dieses Kapitel behandelt Attribute, Funktionen und Statecharts wichtiger Klassen.

\subsubsection*{SD-Karte}

Die Implementierung der SD-Karte erfolgt durch die MDK Middleware File System Component in der Version 6.9.8. Die File System Component unterstützt eine Vielzahl an Speichern und Speichergeräten, welchen jeweils ein Laufwerksbuchstabe zugewiesen ist. Der Laufwerksbuchstabe wird an Systemroutinen übergeben, wo er zur Initialisierung eines Dateisystems verwendet wird. Das Dateisystem, wie beispielsweise File Allocation Table (FAT) File System oder Embedded File System (EFS) wird in Abhängigkeit vom Laufwerk festgelegt. Die Klasse \texttt{SDCard} mit ihren Attributen und Operationen ist in \autoref{fig:SDCardClass} dargestellt. Dabei legt das Attribut \texttt{drive} den Laufwerksbuchstaben "`M0:"' und das damit verbundene Dateisystem FAT fest.

\begin{figure}[!b]
	\centering
		\includegraphics[width=0.5\textwidth]{images/SDCardClass.pdf}
		\caption{Klassendiagramm der SD-Karte.}
	\label{fig:SDCardClass}
\end{figure}

\paragraph{Initialisierung:}
Das Sequenzdiagramm in \autoref{fig:SDCardInit} stellt den Ablauf der Operation \texttt{init\-And\-Mount} dar. Dabei erfolgt das Initialisieren und Mounten des Dateisystems über die Systemroutinen \texttt{finit} und \texttt{fmount}. Außerdem sind die entsprechenden Statusmeldungen an das Display im Erfolgsfall (grün) und Fehlerfall (rot) eingezeichnet.

\begin{figure}[!hbt]
	\centering
		\includegraphics[width=1\textwidth]{images/SDCardInit.pdf}
		\caption{Initialisieren und Mounten der SD-Karte.}
	\label{fig:SDCardInit}
\end{figure}

\paragraph{Lesen:}
Leseoperationen erfolgen mit Hilfe der Standard Input und Output Library \texttt{stdio.h}. Die Library \texttt{stdio.h} benutzt Datenströme (Stream)zur Kommunikation mit physikalischen Peripheriegeräten wie Tastatur und Drucker, oder auch zur Kommunikation mit jeder anderen Art von Dateien, welche das System unterstützt. Dabei werden die Streams immer identisch angewendet, unabhängig davon, ob mit einem Gerät oder einer Datei kommuniziert wird. Durch die Funktion \texttt{fopen} wird ein Stream geöffnet und mit einem Gerät oder einer Datei verbunden. Bei erfolgreichem Öffnen des Streams gibt die Funktion \texttt{fopen} einen Zeiger auf ein FILE-Objekt zurück. Dieser Zeiger beinhaltet alle Informationen des Datenstroms und muss bei jeder weiteren Dateioperation als Parameter übergeben werden.

Der für dieses Szenario implementierte Lese-Mechanismus ist als Sequenzdiagramm in \autoref{fig:SDCardRead} abgebildet. Nach dem Öffnen des Streams wird mit der Funktion \texttt{fgets} Zeile für Zeile aus dem Logfile ausgelesen, bis das Ende der Datei erreicht ist. 

\begin{figure}[!hbt]
	\centering
		\includegraphics[width=1\textwidth]{images/SDCardRead.pdf}
		\caption{Lesen der SD-Karte.}
	\label{fig:SDCardRead}
\end{figure}

Da alle Zeilen des Logfiles das gleiche Format haben, kann aus der letzten Zeile die fortlaufende Nummer extrahiert und zum Setzen des Zählers benutzt werden (siehe \autoref{fig:SDCardSzenario}). Den entsprechenden Ausschnitt aus der Operation \texttt{read} zeigt \autoref{lst:ExtractCounter}. Dabei wird zunächst der Teil der Zeichenkette ab dem \#-Symbol extrahiert. Danach wird mit der Funktion \texttt{scanf} der Dezimalwert ausgelesen und in \texttt{counter} geschrieben.

Im Anschluss wird das Event \texttt{evSDLog} mit der Bezeichnung "`R:" für \textit{Read} und der letzten gelesenen Zeile als Parameter an das Display gefeuert. Nach erfolgter Dateioperation muss der Datenstrom wieder mittels \texttt{fclose} geschlossen werden.

\lstset{escapechar=@, escapeinside={(*@}{@*)}, style=customcpp}
\begin{lstlisting}[caption={Extrahieren des aktuellen Zählstandes aus dem Logfile.}, captionpos=b, label={lst:ExtractCounter}]
// Set counter to last value
substring = strstr(line, "# ");
if (substring != NULL)
{
	/* Found "# " in row. Extract decimal */
	sscanf(substring + 3, "%d", &counter);
}  
\end{lstlisting}

\paragraph{Schreiben:}
Wie die Leseoperationen bedienen sich auch die Schreiboperationen bei der Standard Input und Output Library \texttt{stdio.h}. Gleichermaßen gilt es zunächst einen Stream zu Öffnen um einen Zeiger auf ein FILE-Objekt zu erhalten. Im Gegensatz zur Leseoperation, welche die Funktion \texttt{fopen} mit dem Parameter "`r"' für \textit{Read mode} aufruft, wird bei der Schreiboperation der Parameter "`a"' für \textit{Append mode} verwendet. Der \textit{Append mode} öffnet eine bestehende Datei und fügt dieser Inhalte hinzu. Falls die Datei noch nicht besteht, wird eine leere Datei angelegt. Wenn eine Datei im \textit{Append mode} geöffnet wird, werden die neuen Inhalte stets am Ende der Datei hinzugefügt.

\begin{figure}[!b]
	\centering
		\includegraphics[width=1\textwidth]{images/SDCardWrite.pdf}
		\caption{Schreiben auf die SD-Karte.}
	\label{fig:SDCardWrite}
\end{figure}

Der implementierte Schreib-Mechanismus ist in \autoref{fig:SDCardWrite} als Sequenzdiagramm dargestellt. Nach dem Öffnen des Datenstroms wird die Zeichenkette \texttt{str}  durch die Funktion \texttt{fprintf} in den Stream geschrieben. Die Funktion \texttt{fflush} sorgt letztendlich dafür, dass die Schreiboperation ausgeführt wird. Das bedeutet, dass die zugehörigen Buffer geleert und deren Inhalt in die entsprechende Datei geschrieben wird. Sollte der Rückgabewert der Funktion \texttt{fflush} ungleich Null sein, so ist ein Fehler aufgetreten. Die Klasse \texttt{SDCard} feuert in diesem Fall das Event \texttt{evSDLog} mit einer entsprechenden Fehlermeldung an das Display, sowie das Event \texttt{evError} an sich selbst (siehe rote Markierungen in \autoref{fig:SDCardWrite}). Durch das Event \texttt{evError} geht die Klasse \texttt{SDCard} in einen internen Fehlerstatus. Bei einer erfolgreichen Schreiboperation feuert die Klasse \texttt{SDCard} ebenfalls das Event \texttt{evSDLog} an das Display. In diesem Fall beinhaltet der Parameter des Events \texttt{evSDLog} den Bezeichner "`W:"' für \textit{Write} sowie die aktuell geschriebene Zeile. Zuletzt muss der Datenstrom durch die Funktion \texttt{fclose} wieder geschlossen werden.

\paragraph{Datei anlegen:}
Das Anlegen einer Datei geschieht implizit beim Aufruf der Funktion \texttt{fopen}. Dabei ist der Übergabeparameter für den Zugriffsmodus entscheidend. Mit "`a"' für \textit{Append mode} wird nur dann eine leere Datei angelegt, wenn diese noch nicht existiert. Mit dem Parameter "`w"' für \textit{Write mode} wird bei jedem Aufruf eine leere Datei angelegt. Eine existierende Datei wird dabei überschrieben.

\paragraph{Datei löschen:}
Zum Löschen einer Datei dient die Funktion \texttt{fdelete}. Als Parameter wird dieser Funktion der Name einer zu löschenden Datei oder eines Verzeichnisses übergeben. Mit einem weiteren Parameter "`/S"' wird spezifiziert, ob bei Angabe eines Verzeichnisses alle Dateien und Unterverzeichnisse ebenfalls gelöscht werden sollen. Die Funktion \texttt{fdelete} liefert einen Rückgabewert vom Typ \texttt{fsStatus} der eine detaillierte Fehlerbehandlung ermöglicht. 

\subsubsection*{Joystick}

\subsubsection*{Clock}

\subsubsection*{Display}

\subsection{Konfigurieren des Keil Projekts}

Wie in auch in den vorherigen Implementierungen wurde das Blinky-Beispielprojekt aus dem RXF \textit{Rpy\_CPP\_CMSIS\_Keil5\_ARM\_MCB1700\_TD} von Willert verwendet. Dadurch ist das Zusammenspiel von Rational Rhapsody, dem Willert RXF und der IDE Keil uVision sichergestellt. Nachfolgend werden die wichtigsten Anpassungen in der Konfiguration dargestellt.

\subsubsection*{Manage Run-Time Environment} 

Zur Verwendung der SD-Karte ist es nötig dem Keil Projekt, mit Hilfe des Konfigurationsassistenten \includegraphics[width=0.3cm]{images/package.pdf} \textit{Manage Run"=Time Environment}, Software Komponenten hinzuzufügen. Zuallerst wird der Software Pack \textit{Keil::MDK"=Middleware} in der Version 7.4.1 (2017-04-21) dem Projekt hinzugefügt. In diesem Paket ist die File System Component in der Version 6.9.8 (2017-04-21) enthalten. Zur Verwendung der File System Component wird der \textit{ARM::CMSIS:CORE} in der Version 5.0.1 benötigt. Zwar erstellt die File System Component keinen eigenen Thread, greift aber dennoch auf die Schnittstellen des Betriebssystems zu. Das geschieht beispielsweise dann, wenn eine Datei geöffnet wird und mittels Mutex ein exklusiver Zugriff auf die Datei gewährleistet wird. Die entsprechende Anpassung in der Run-Time Environment ist in \autoref{tab:RuntimeEnvSdCard} rot markiert.

Die File System Component unterstützt sowohl das Betreiben rudimentärer Flash-Speicher-Chips in NAND- oder NOR-Architektur, als auch den Datenaustausch mit einem USB Massenspeicher oder einer SD Speicherkarte. Die benötigten Komponenten der File System Component für den Einsatz der SD Speicherkarte sind in \autoref{tab:RuntimeEnvSdCard} gelb gekennzeichnet. 

\begin{table}[!ht]
\centering
\footnotesize
\begin{tabular}{p{0.01mm}p{4.6cm}p{0.2cm}p{2.2cm}lp{0.2cm}p{2.2cm}l}
	\toprule
	& & \multicolumn{3}{ c }{Blinky} & \multicolumn{3}{ c }{SD Card} \\ \cmidrule{3-5}  \cmidrule{6-8}
	& Software Component & Sel. & Variant & Version & Sel. & Variant & Version \\
	\midrule
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Board Support & & \tiny{MCB1700} & 1.0.0 & \cellcolor{KeilGreen} & \tiny{MCB1700} & 1.0.0 \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Graphic LCD (API) &  &  & 1.0.0 & \cellcolor{KeilGreen} &  & 1.0.0 \\
	\textcolor{Orange}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFii\textSFx\textSFx	\includegraphics[width=0.2cm]{images/item.pdf} Graphic LCD & \HollowBox &  & 1.0.0 & \cellcolor{KeilGreen}\CheckedBox &  & 5.0.1 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} CMSIS & \cellcolor{KeilGreen} & & & \cellcolor{KeilGreen} & & \\
	\textcolor{Red}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFii\textSFx\textSFx	\includegraphics[width=0.2cm]{images/item.pdf} CORE & \cellcolor{KeilGreen}\CheckedBox  &  & 4.3.0 & \cellcolor{KeilGreen}\CheckedBox &  & 5.0.1 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} CMSIS Driver & & & & \cellcolor{KeilGreen} & & \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} SPI (API) & & & 2.01 & \cellcolor{KeilGreen} &  & 2.2.0 \\
	& \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} SPI & \HollowBox  &  & 2.1 & \HollowBox &  & 2.1.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{5ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} SSP & \HollowBox  &  & 2.5 & \cellcolor{KeilGreen}\CheckedBox &  & 2.7.0 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Compiler & & \tiny{ARM Compiler} & 1.2.0 & \cellcolor{KeilGreen} & \tiny{ARM Compiler} & 1.2.0 \\
	& \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} Event Recorder & \HollowBox  & \tiny{DAP} & 1.1.0 & \HollowBox & \tiny{DAP} & 1.1.0 \\
	& \textSFxi\hspace{2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} I/O &  &  & & \cellcolor{KeilGreen} &  & \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} File & \HollowBox & \tiny{File System} & 1.2.0 & \cellcolor{KeilGreen} \CheckedBox & \tiny{File System} & 1.2.0 \\
	& \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} STDERR & \HollowBox & \tiny{User} & 1.2.0 & \HollowBox & \tiny{User} & 1.2.0 \\
	& \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} STDIN & \HollowBox & \tiny{User} & 1.2.0 & \HollowBox & \tiny{User} & 1.2.0 \\
	& \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} STDOUT & \HollowBox & \tiny{User} & 1.2.0 & \HollowBox & \tiny{User} & 1.2.0 \\
	& \textSFxi\hspace{5ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} TTY & \HollowBox & \tiny{User} & 1.2.0 & \HollowBox & \tiny{User} & 1.2.0 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Device & & & & \cellcolor{KeilGreen} & & \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} GPDMA & \HollowBox &  & 1.2 & \cellcolor{KeilGreen}\CheckedBox &  & 1.2.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} GPIO & \HollowBox &  & 1.1 & \cellcolor{KeilGreen}\CheckedBox &  & 1.1.0 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} PIN & \HollowBox &  & 1.0 & \cellcolor{KeilGreen}\CheckedBox &  & 1.0.0 \\
	& \textSFxi\hspace{2ex}\textSFii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} Startup & \cellcolor{KeilGreen}\CheckedBox &  & 1.0.0 & \cellcolor{KeilGreen}\CheckedBox &  & 1.0.0 \\
	& $\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} File System & & \tiny{MDK-Pro} & 6.9.8 & \cellcolor{KeilGreen} & \tiny{MDK-Pro} & 6.9.8 \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{3.2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} CORE & \HollowBox & \tiny{SFN} & 6.9.8 & \cellcolor{KeilGreen}\CheckedBox & \tiny{LFN} & 6.9.8 \\
	& \hspace{3.2ex}$\boxminus$\textSFx \includegraphics[width=0.25cm]{images/package.pdf} Drive & & & & \cellcolor{KeilGreen} &  & \\
	\textcolor{Yellow}{ \pmboxdrawuni{258E}} & \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/items.pdf} Memory Card & 0  &  & 6.9.8 & \cellcolor{KeilGreen} 1 &  & 6.9.8 \\
	& \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/items.pdf} NAND & 0  &  & 6.9.8 & 0 &  & 6.9.8 \\
	& \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/items.pdf} NOR & 0  &  & 6.9.8 & 0 &  & 6.9.8 \\
	& \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/item.pdf} RAM & \HollowBox &  & 6.9.8 & \HollowBox &  & 6.9.8 \\
	& \hspace{3.2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx \includegraphics[width=0.20cm]{images/items.pdf} USB & 0  &  & 6.9.8 & 0 &  & 6.9.8 \\
	\bottomrule
\end{tabular}
\caption{Heraufsetzen des CMSIS:CORE (rot), benötigte Komponenten der File System Component und deren Abhängigkeiten (gelb), sowie die Komponenten zum Betreiben des Displays (orange).}
\label{tab:RuntimeEnvSdCard}
\end{table}

\subsubsection*{CMSIS Configuration} 
Die CMSIS Configuration behandelt die Einstellung des CMSIS RTX Kernel. Zwar legt die File System Component keine neuen Threads an, benötigt aber dennoch das CMSIS-RTOS zum Betrieb. Beispielsweise werden die Mechanismen zum Erstellen eines Mutex verwendet. Die Anforderungen an den CMSIS RTX Kernel werden in der Datei \textit{RTX\_Conf\_CM.c} eingepflegt, welche Teil der CMSIS Component ist. Diese Datei kann über den \textit{Configuration Wizard} von Keil editiert werden. Im Abschnitt \textit{Thread Configuration} in der Datei \textit{RTX\_Conf\_CM.c} spezifiziert der erste Parameter \textit{Number of concurrently running user threads} die Anzahl nebenläufiger Tasks. Die Tasks der SD-Karten Applikation sind in \autoref{tab:DefaultThreadsSDCard} aufgelistet. Dabei sind die Tasks mit der Ursache CMSIS-RTOS und Willert RXF identisch zu den Tasks in \autoref{tab:DefaultThreads} aus der Ethernet-Applikation. 

\begin{table}[!hbt]
\centering
\footnotesize
	\begin{tabular}{lcl}
	\toprule
	Task Name & Priorität & Ursache \\
	\midrule
	osTimerThread & 1 & CMSIS-RTOS \\
	main & 2 & CMSIS-RTOS \\
	os\_idle\_demon & 255 & CMSIS-RTOS \\
	WST\_\-Monitor\_receiveTask & 3 & Willert RXF \\
	RunningIndicator & 4 & SD-Karte Applikation \\
	Joystick & 5 & SD-Karte Applikation \\
	\bottomrule
	\end{tabular}
\caption{Verwendete Task für den Betrieb der SD-Karte und deren Ursache.}
\label{tab:DefaultThreadsSDCard}
\end{table}

Gemäß \citet{CmsisRtos2017} geht der Task \textit{os\_idle\_demon} nicht in die Anzahl der gleichzeitig laufenden Tasks mit ein, weshalb der Parameter \textit{Number of concurrent running user threads} auf den Wert fünf gesetzt wird. Dementsprechend ist auch der Parameter \textit{Number of threads with user-provided stack size} auf den Wert vier zu setzen, da hier der main-Task nicht mitgezählt wird. 

Abhängig vom gewählten Drive Type gibt \citet{FileSystemComponentResourceRequirements2017} vor, wie die Parameter bezüglich der \textit{Default}, \textit{Main} und \textit{Total Thread stack size} zu konfigurieren sind. Für den hier gewählten Drive Type \textit{Memory Card drive 0} in Kombination mit dem CMSIS Treiber für SPI sind keine weiteren Anpassung nötig. Die Änderungen in der Datei \textit{RTX\_Conf\_CM.c} gegenüber dem Blinky-Projekt sind in \autoref{tab:RtxConfigSDCard} zusammengefasst.

\begin{table}[!htb]
\footnotesize
\centering
	\begin{tabular}{p{7.6cm}p{3.0cm}p{3.0cm}}
	\toprule
	& Blinky & SD-Karte \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxminus$\textSFx Thread Configuration & &  \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Number of concurrent running user threads & 6 & 5 (-1) \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Default Thread stack size [bytes] & 200 & 200 \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Main Thread stack size [bytes] & 1024 & 1024 \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Number of threads with user-provided & 5 & 4 (-1) \\
	\textSFxi\hspace{2ex}\textSFxi \hspace{1.5ex} stack size &  & \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx Total stack size [bytes] for threads with & 4096 & 5632 (+1536)\\
	\textSFxi\hspace{2ex}\textSFxi \hspace{1.5ex} user-provided stack size &  & \\
	\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx  Check for stack overflow & \CheckedBox &  \CheckedBox \\
	\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx  Processor mode for thread execution & Privileged mode & Privileged mode \\
	$\boxplus$\textSFx RTX Kernel Timer Tick Configuration & & \\
	$\boxplus$\textSFx System Configuration & & \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der RTX Configuration \textit{RTX\_Conf\_CM.c} für die SD-Karte.}
\label{tab:RtxConfigSDCard}
\end{table}

Der Vollständigkeit halber wird an dieser Stelle noch auf die Anforderungen bezüglich Mutexes eingegangen, auch wenn im Rahmen dieser Implementierung keine Anpassung nötig sind. Sollen mehr als drei Dateien gleichzeitig geöffnet und bearbeitet werden, muss die Anzahl der Mutexobjekte angepasst werden. Diese Änderung kann nicht über den \textit{Configuration Wizard} erfolgen, sondern muss direkt in der Datei \textit{RTX\_Conf\_CM.c} manuell durchgeführt werden. Dabei ist der Parameter \textit{OS\_MUTEXCNT} zu editieren, welcher standardmäßig auf den Wert acht gesetzt ist. Der Parameter \textit{OS\_MUTEXCNT} setzt sich dabei folgendermaßen zusammen: 2 (internal stdio operations) + 3 (stdin, stdout und stderr file streams) + 3 für jede geöffnete Datei.

\subsubsection*{Device Configuration}

Die Dateien \textit{startup\_LPC17xx.s (Startup)}, \textit{startup\_LPC17xx.c (Startup)} und \textit{RTE\_Device.h (Startup)} implementieren den Start-up Code, welcher direkt nach einem RESET des Targets ausgeführt wird. Alle drei Dateien gehören zur Device Component und können ebenfalls über den \textit{Configuration Wizard} bearbeitet werden. Von größerem Interesse ist zunächst die Datei \textit{startup\_LPC17xx.s (Startup)} bei der festgelegt wird, wie viel Speicher für Stack und Heap zu reservieren sind.

Bei Verwendung der File System Component ist eine Vergrößerung der Stack Size um 512 Bytes nötig. Eine Anpassung des Heaps ist ebenfalls erforderlich und hängt dabei mit der Anzahl gleichzeitig geöffneter Dateien zusammen. Für jede geöffnete Datei müssen 512+96 Bytes reserviert werden. In diesem Fall soll nur eine Datei gleichzeitig geöffnet werden \parencite{FileSystemComponentResourceRequirements2017}.  Wie \autoref{tab:StartupConfigSDCard} zu entnehmen ist, wurde der Heap insgesamt um 4096 Bytes vergrößert. Die Differenz von 3488 Bytes kommt für den Betrieb des Logging-Mechanismus auf dem Display zum Einsatz. Dieser Mechanismus basiert auf der Klasse \texttt{OMString}, welche Teil des Rhapsody OXF ist und zusätlichen Heap benötigt.

\begin{table}[!hbt]
\footnotesize
\centering
	\begin{tabular}{p{7.6cm}p{3.0cm}p{3.0cm}}
	\toprule
	& Blinky & SD-Karte \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxminus$\textSFx Stack Configuration & &  \\
	\textSFxi\hspace{2ex}\textSFii\textSFx\textSFx Stack Size (in Bytes) & 0x0000 0200 & 0x0000 0400 (+512) \\
	$\boxminus$\textSFx Heap Configuration & & \\
  \hspace{3ex}\textSFii\textSFx\textSFx Heap Size (in Bytes) & 0x0000 1000 & 0x0000 2000 (+4096) \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der Startup Configuration \textit{startup\_LPC17xx.s (Startup)} für die SD-Karte.}
\label{tab:StartupConfigSDCard}
\end{table}

Die Datei \textit{RTE\_Device.h (Startup)} muss ebenfalls angepasst werden. In ihr erfolgt die Pin Konfiguration für die verschiedenen Schnittstellen des Keil MCB1760 Eval Boards. Da in dieser Implementierung die SD-Karte mittels SPI angesprochen wird, müssen die entsprechenden Pins dem SPI Treiber \textit{Driver\_SPI0} zugewiesen werden. Die Zuordnung der Pins zu den jeweiligen SPI-Leitungen ist in \autoref{tab:DeviceConfigSDCard} abgebildet. Der SPI Treiber \textit{Driver\_SPI1} ist ebenfalls aktiviert, er ist zum Betrieb des Displays nötig.

\begin{table}[!htb]
\footnotesize
\centering
	\begin{tabular}{p{10.6cm}p{1.5cm}p{1.5cm}}
	\toprule
	& Blinky & SD-Karte \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{USB Controller [Driver\_USBD and Driver\_USBH]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{ENET (Ethernet Interface) [Driver\_ETH\_MAC0]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{I2C0 (Inter-integrated Circuit Interface 0) [Driver\_I2C0]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{I2C1 (Inter-integrated Circuit Interface 1) [Driver\_I2C1]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{I2C2 (Inter-integrated Circuit Interface 2) [Driver\_I2C2]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{UART0 (Universal asynchronous receiver transmitter)} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{UART1 (Universal asynchronous receiver transmitter)} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{UART2 (Universal asynchronous receiver transmitter)} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{UART3 (Universal asynchronous receiver transmitter)} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{CAN1 Controller [Driver\_CAN1]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{CAN2 Controller [Driver\_CAN2]} & \HollowBox & \HollowBox \\
	$\boxminus$\textSFx SSP0 (Synchronous Serial Port 0) [Driver\_SPI0] & \HollowBox & \CheckedBox \\
	\textSFxi\hspace{2ex}$\boxminus$\textSFx Pin Configuration & & \\
	\textSFxi\hspace{2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx SSP0\_SSEL & & P0\_16 \\
	\textSFxi\hspace{2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx SSP0\_SCK & & P0\_15 \\
	\textSFxi\hspace{2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx SSP0\_MISO & & P0\_17 \\
	\textSFxi\hspace{2ex}\textSFxi\hspace{2ex}\textSFviii\textSFx\textSFx SSP0\_MOSI & & P0\_18 \\
	\textSFxi\hspace{2ex}$\boxminus$\textSFx DMA & & \\
	\textSFxi\hspace{2ex}\hspace{3ex}$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{Tx} & \HollowBox & \HollowBox \\
	\textSFxi\hspace{2ex}\hspace{3ex}$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{Rx} & \HollowBox & \HollowBox \\
	$\boxminus$\textSFx SSP1 (Synchronous Serial Port 1) [Driver\_SPI1] & \HollowBox & \CheckedBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{SPI (Serial Periperhal Interface [Driver\_SPI2]} & \HollowBox & \HollowBox \\
	$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{I2S0 (Integrated Interhip Sound 0 [Driver\_SAI0]} & \HollowBox & \HollowBox \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der File System Configuration \textit{FS\_Config\_MC\_0.h (Drive:Memory Card)}.}
\label{tab:DeviceConfigSDCard}
\end{table}



\subsubsection*{File System Configuration}

Die Konfiguration des File Systems geschieht über die Dateien \textit{FS\_Config.c (CORE)} und \textit{FS\_Config\_MC\_0.h (Drive:Memory Card)}. Durch die zuvor erfolgte Konfiguration der \textit{Run-Time Environment} wurden die beiden Dateien der File System Component hinzugefügt. Die Datei \textit{FS\_Config.c (CORE)} kann bei den Standardeinstellungen belassen werden, wohingegen bei der Datei \textit{FS\_Config\_MC\_0.h (Drive:Memory Card)} eine wichtige Änderung vorzunehmen ist. Dies betrifft den Parameter \textit{Memory Card Interface Mode}, welcher von \textit{Native} auf \textit{SPI} umgestellt wird.

\begin{table}[!htb]
\footnotesize
\centering
	\begin{tabular}{p{7.6cm}p{3.0cm}p{3.0cm}}
	\toprule
	& Blinky & SD-Karte \\ \cmidrule{2-3}
	Option & Value & Value \\
	\midrule
	$\boxminus$\textSFx Memory Card Drive 0 & &  \\
	\hspace{3.2ex}\textSFviii\textSFx\textSFx Connected to hadware via Driver\_MCI\# & 0 & 0 \\
	\hspace{3.2ex}\textSFviii\textSFx\textSFx Connected to hadware via Driver\_SPI\# & 0 & 0 \\
	\hspace{3.2ex}\textSFviii\textSFx\textSFx Memory Card Interface Mode & Native & SPI \\
	\hspace{3.2ex}\textSFviii\textSFx\textSFx Drive Cache Size & 4 KB & 4 KB \\
	\hspace{3.2ex}$\boxplus$\textSFx \textcolor[rgb]{0.5,0.5,0.5}{Locate Drive Cahce and Drive Buffer} & \HollowBox & \HollowBox \\
	\hspace{3.2ex}\textSFviii\textSFx\textSFx Filename Chache Size & 0 & 0 \\
	\hspace{3.2ex}\textSFii\textSFx\textSFx Use FAT Journal & \HollowBox & \HollowBox \\
	\bottomrule
	\end{tabular}
\caption{Anpassungen in der File System Configuration \textit{FS\_Config\_MC\_0.h (Drive:Memory Card)}.}
\label{tab:FileSystemConfigSDCard}
\end{table}